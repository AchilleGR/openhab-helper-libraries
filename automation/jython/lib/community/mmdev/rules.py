# Library for creating auto-generated rules throughout a codebase.

from functools import wraps

from core import jsr223
from core import rules
from core import triggers

from core.exceptions import suppress
from core.log import log_traceback, getLogger
from . import items
from . import types

from functools import wraps
from uuid import uuid4
import traceback


LOGGER = getLogger('mmdev.rules')


jsr223.scope.scriptExtension.importPreset("RuleSimple")
jsr223.scope.scriptExtension.importPreset("RuleSupport")
jsr223.scope.scriptExtension.importPreset("RuleFactories")


def rule(condition, pass_context=False):
    def decorator(function):
        @rules.rule(
            'MMDEV-%s' % (str(uuid4())),
            description='Auto-generated rule',
            tags=['Autogenerated', 'MMDEV'],
        )
        @triggers.when(condition)
        @wraps(function)
        def wrapper(event):
            try:
                if pass_context:
                    function(event)
                else:
                    function()
            except:
                LOGGER.warning(
                    'Exception in condition handler:\nRule: {}\n{}'.format(
                        condition, traceback.format_exc()
                    )
                )
        return function
    return decorator


def cron(timespec):
    return rule('Time cron "%s"' % timespec)


def on_change(item, pass_context=False, null_context=False):
    def decorator(function):
        @rule(
            'Item %s changed' % item, 
            pass_context=True
        )
        @wraps(function)
        def wrapper(event):
            if not pass_context:
                return function()

            old_item_value = types.from_type(event.oldItemState)
            new_item_value = types.from_type(event.itemState)
            if null_context or (old_item_value is not None and new_item_value is not None):
                return function(old_item_value, new_item_value)
        return function
    return decorator


def on_command(item, pass_context=False, null_context=False):
    def decorator(function):
        @rule(
            'Item %s received command' % item, 
            pass_context=True
        )
        @wraps(function)
        def wrapper(event):
            if not pass_context:
                return function()
            value = types.from_type(event.itemCommand)
            if null_context or value is not None:
                return function(value)
        return function
    return decorator


def on_update(item, pass_context=False, null_context=False):
    def decorator(function):
        @rule(
            'Item %s received update' % item, 
            pass_context=True
        )
        @wraps(function)
        def wrapper(event):
            if not pass_context:
                return function()
            value = types.from_type(event.itemState)
            if null_context or value is not None:
                return function(value)
        return function
    return decorator
